Современные распределённые графовые базы данных сталкиваются с фундаментальной проблемой эффективного распределения вершин графа по узлам хранения (шардам). Оптимальное распределение становится критически важным для производительности систем, где основной операцией является поиск путей между вершинами, которые могут находиться в разных шардах. Неэффективное распределение приводит к значительным задержкам при выполнении запросов и избыточным сетевым коммуникациям между узлами.

Актуальность данной работы обусловлена стремительным ростом объёмов графовых данных в таких областях, как социальные сети, рекомендательные системы, биоинформатика и интернет вещей. Традиционные подходы к распределению данных демонстрируют ограниченную эффективность при работе с графами, требующими учёта структурных особенностей и связности вершин.

В рамках исследования проводится сравнительный анализ двух принципиально различных подходов к распределению графов: потоковых методов (online partitioning), работающих в реальном времени по мере поступления данных, и методов оптимизации распределения (offline partitioning), требующих полного знания структуры графа. Особое внимание уделяется алгоритмам библиотеки METIS, представляющей собой промышленный стандарт для задач разбиения графов, и современным потоковым алгоритмам, таким как Fennel и Streaming Graph Partitioning.

Целью работы является исследование и сравнение эффективности различных методов распределения вершин графа по гомогенным хранилищам, а также разработка предложений по комбинированию подходов для достижения оптимального баланса между качеством разбиения и вычислительной эффективностью в условиях реальной эксплуатации распределённых графовых баз данных.
В распределённую графовую БД поступают или же поступали вершины графа. Основной операцией в БД будет поиск пути между вершинами, которые могут оказаться в разных хранилищах БД. Для максимизации эффективности этой операции требуется решить следующую задачу.

Дан граф $G=(V,E)$, $|V|=n, |E|=m$. Распределение графа - это такое $P=\{S_1,S_2...S_k\}$, гдe $S_i$ - набор вершин (далее шард) $v\in V$, при этом $S_i\cap S_j=\emptyset$.

Требуется найти такое распределение $P^*=\{S^*_1,S^*_2...S^*_k\}$,  так, чтобы минимизировать общую мощность разрезов $|\partial e(P)|=|\cup^n_{i=1}e(S^*_i,V\backslash S^*_i)|$, либо же $\lambda=\frac{|\partial e(P)|}{m}\times100\%$. А также минимизировать нормализованную максимальную нагрузку $\rho=\frac{max^n_{i=1}(|S^*_i|)}{\frac{n}{k}}$ (максимизировать балансировку). 

METIS (от MEtis Tournament Inspired Strategy) \cite{MetisOG} — это набор программных библиотек и утилит, разработанных в Университете Миннесоты, для разбиения больших неориентированных графов и разрежения матриц.

Ключевая идея METIS — многоуровневая парадигма (Multilevel Paradigm). Вместо того чтобы работать с огромным исходным графом напрямую, METIS последовательно его упрощает, находит разбиение для маленького графа и затем интерполирует это разбиение обратно на исходный граф. 

Алгоритм состоит из трёх этапов: 
Схлопывание/Упрощение/Свёртка (англ. Coarsening) - уменьшение графа схлопыванием вершин в граф $G_l$. \\
Исходный граф G0 последовательно преобразуется во всё более мелкие графы $G_1, G_2, ..., G_l$. На каждом шаге пары смежных вершин "схлопываются/сворачиваются" в одну супервершину.

Распределение (англ. Partitioning) - распределение (разбиение) графа $G_l$. Поскольку граф $G_l$ очень мал, для его разбиения можно использовать даже очень дорогие (вычислительно сложные) алгоритмы.

Развёртка (англ. Uncoarsening) - развёртка графа $G_l$, то есть действие обратное первому этапу. Также происходит улучшение (англ. refinement) - оптимизация разбиения в процессе развёртки. Порядок следующий:

Разбиение, найденное для $G_l$, проецируется на граф $G_{m-1}$. Так как каждая вершина в $G_{m-1}$ соответствовала вершине в $G_l$, разбиение определяется автоматически.

Улучшение, то есть переброс вершин между шардами для получения лучшего распределения.

Первые два пункта повторяются пока не будет получено разбиение для $G_0$.

Свёртка в Metis сводится к поиску максимального паросочетания, но не наибольшего, так как это слишком затратное действие. и дальнейшего схлопывания рёбер паросочетания.

В базовом методе рассматриваются 4 алгоритма поиска максимального паросочетания:
Cлучайное (англ. Random Matching - RM) - берётся случайное ребро, затем случайное ребро, несмежное с ним, после чего ребро не связанное с выбранными ранее, и так далее пока таких рёбер не останется. Метод прост и эффективен для локальной задачи, но для уменьшения общей мощности разрезов в дальнейшем подходит плохо.
Паросочетание тяжёлых рёбер (англ. Heavy Edge Matching - HEM) - выбор рёбер максимального веса по очереди. Экспериментально было установлено, что это приводит к хорошему уменьшению общей мощности разрезов. В Metis этот алгоритм используется как основной.
Паросочетание лёгких рёбер (англ. Light Edge Matching - LEM) - выбор рёбер минимального веса по очереди. Алгоритм приводит к большему общему весу рёбер у свёрнутого графа, что может положительно влиять на качество улучшения некоторыми алгоритмами.
Паросочетание тяжёлых клик (англ. Heavy Clique Matching - HCM) - объединяет вершины, максимизируя плотность ребер создаваемого подграфа.

В отличие от HEM, который выбирает тяжелые ребра, HCM оценивает, насколько две вершины (точнее вершины, которые свернулись в них) близки к формированию клики. Для вершин $u$ и $v$ вычисляется плотность рёбер (англ. edge density) по формуле:

Алгоритм схож с HEM, но учитывает и вершины изначального графа.
Алгоритмы распределения

Этап распределения является решением поставленной в секции 1 задачи для свёрнутого графа. В Metis рекурсивно используются алгоритмы бисекции графа, поэтому число шардов $k$ должно быть степенью двойки, другоие $k$ приведут к плохой балансировке.

На этом этапе также рассматриваются 4 алгоритма:

Разбиение: $P[j]=1$ если $y_j\le r$, и $P[j]=2$ в противном случае, где $r$ — выбранная взвешенная медиана $y_j$.
Алгоритм Кернигана-Лина (англ. Kernighan-Lin - KL) - алгоритм, работающий на идее улучшения разбиения путём обмена вершин между шардами. Для этого определена следующая функция улучшения распределения:

при положительном $g_v$ перемещение вершины $v$ приведёт к улучшению распределения. За одну итерацию алгоритм проходится по всем вершинам и пытается переместить все, итерации прерываются как только никакое перемещение не приведёт к улучшению, либо когда будет достигнуто предельное число операций. Эксперименты показали, что для достаточно хорошего распределения как правило хватает 5-10 итераций.\cite{MetisOG}. Для избегания работы "вхолостую" итерация прерывается при 50 перемещений без улучшения, что хорошо показало себя при экспериментах. Также стоит отметить, что ещё можно ограничить алгоритм на минимальное кол-во перемещений за итераций. 
    
Функция улучшения может быть рассчитана для всех вершин в начале итерации и при перемещении вершины обновляться только для соседей перемещённой вершины для оптимизации. 
Алгоритм роста графа (англ. Graph Growing - GGP) - выбирается случайная вершина и от неё как при поиске в ширину обходятся вершины, формируя подграф, пока не будет набрана ровно половина вершин. Этот подграф будет первым шардом, остальные вторым. Далее рекомендуется применить KL для улучшения, что не займёт много времени в силу малого размера свёрнутого графа. Также стоит отметить, что вполне можно делить не пополам, а на другие равные части и применять KL к шардам попарно.
Жадный алгоритм роста графа (англ. Greedy Graph Growing - GGGP) - так как для предыдущего алгоритма и так рекомендуется применять KL после бисекции можно сразу при обходе графа идти по вершинам, которые будут давать наибольшее улучшение.